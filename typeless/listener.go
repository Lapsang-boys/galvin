// generated by Textmapper; DO NOT EDIT

package typeless

import (
	"fmt"
)

type NodeType int

type Listener func(t NodeType, offset, endoffset int)

const (
	NoType NodeType = iota
	File  // Expressions=(Expression)*
	FunctionAbstraction  // Parameters=(Identifier)* Body
	Body  // Expression
	FunctionApplication  // Callee=Expression Arguments=(Expression)*
	Literal
	Identifier
	NodeTypeMax
)

var nodeTypeStr = [...]string{
	"NONE",
	"File",
	"FunctionAbstraction",
	"Body",
	"FunctionApplication",
	"Literal",
	"Identifier",
}

func (t NodeType) String() string {
	if t >= 0 && int(t) < len(nodeTypeStr) {
		return nodeTypeStr[t]
	}
	return fmt.Sprintf("node(%d)", t)
}

var Expression = []NodeType{
    FunctionAbstraction,
    FunctionApplication,
    Identifier,
    Literal,
}

var ruleNodeType = [...]NodeType{
	0, // Expression_optlist : Expression_optlist Expression
	0, // Expression_optlist :
	File, // File : Expression_optlist
	0, // Expression : FunctionAbstraction
	0, // Expression : FunctionApplication
	0, // Expression : Literal
	0, // Expression : Identifier
	FunctionAbstraction, // FunctionAbstraction : '(' '\\' Identifier_list_Comma_separated_opt '->' Body ')'
	0, // Identifier_list_Comma_separated : Identifier_list_Comma_separated ',' Identifier
	0, // Identifier_list_Comma_separated : Identifier
	0, // Identifier_list_Comma_separated_opt : Identifier_list_Comma_separated
	0, // Identifier_list_Comma_separated_opt :
	Body, // Body : Expression
	0, // Expression_list_Comma_separated : Expression_list_Comma_separated ',' Expression
	0, // Expression_list_Comma_separated : Expression
	0, // Expression_list_Comma_separated_opt : Expression_list_Comma_separated
	0, // Expression_list_Comma_separated_opt :
	FunctionApplication, // FunctionApplication : Expression '[' Expression_list_Comma_separated_opt ']'
	Literal, // Literal : intLit
	Identifier, // Identifier : identifier_tok
}

